# Общее описание:

Все запросы API представляют из себя JSON с 2мя объектами первого уровня - `header` и `body`(второй может быть равен
null). `header` запроса содержит единственное поле
`type` - вид запроса. Ответы устроены также, но добавляется поле `header`-а `queryType` - вид запроса, на который мы
ответчаем.
В поле `type` при этом записывается вид произведённой операции и степень её успешности или `error`, если запрос
полностью некорректен.

# Запросы:

## Авторизация:

### Авторизация

* **Тип** `login`.
* **Параметры**:
    *`name` -- обязателен, строка. Имя пользователя.
    *`password` -- обязателен, строка. Пароль пользователя.
* **Возврат**:
    * Если запрос успешен вернёт `id` и `type` в `header` будет `success`
    * Иначе флаг `id == -1`,  `type` в `header` будет `incorrectName`

### Регистрация

* **Тип** `register`.
* **Параметры**:
    *`name` -- обязателен, строка. Имя пользователя.
    *`password` -- обязателен, строка. Пароль пользователя.
* **Возврат**:
    * Если запрос успешен вернёт `id` и `type` в `header` будет `success`
    * Иначе флаг `id == -1`,  `type` в `header` будет `nameAlreadyExists`
### Смена пароля

* **Тип** `changePassword`.
* **Параметры**:
    *`name` -- обязателен, строка. Имя пользователя.
    *`new_password` -- обязателен, строка. Новый пароль пользователя.
    *`old_password` -- обязателен, строка. Старый пароль пользователя.
* **Возврат**:
    * Если запрос успешен вернёт `id` и `type` в `header` будет `success`
    * Иначе флаг `id == -1`,  `type` в `header` будет `incorrectName`
    
## Создание игры

* **Тип**: `createGame`.
* **Парамеры**:
    * `dictionaryName` -- обязателен, строка. Название словаря, который будет использоваться в игре. Доступные
      значения: `const`.
        * `words` -- обязателен, если указан тип `const`, вектор строк. Слова, по которым будет игра.
    * `paserName` -- обязателен, строка. Название парсера, который будет использоваться. Доступные значения: `simple`
    * `autoJoin` -- опциональный, булев. Нужно ли присоединиться к игре после её создания.
* **Возврат**:
    * Если запрос корректен, вернет ответ с типом `GameCreatedSuccessfully` и полем `id`, содержащим `id` игры.
        * Если `autoJoin` равен `true`, то так же будут возвращены следующие поля:
            * `joined` -- булево поле, получилось ли присоединиться.
            * `errors` -- строка, ошибка при подключении. Если ошибки не возникло, поле будет пустым.
    * При попытке создания игры во время игры, будет возращена ошибка `alreadyInGameError`.
    * При неверном формате запроса будет возращена ошибка `wrongFormatError`.

## Присоединение к игре

* **Тип**: `joinGame`
* **Параметры**:
    * `id` -- обязателен, число, id игры, которую нужно присоединиться.
* **Возврат**:
    * Если запрос оказался корректным, вернет ответ с типом `GameJoinedSuccessfully` и полем `id` -- id текущей игры.
    * Если запрос имел неверный формат, вернет ошибку `wrongFormatError`.
    * Если была попытка присоединиться в игру во время игры, вернет ошибку `alreadyInGameError`.
    * Если была попытка присоединиться в игру после выхода, вернет ошибку `connectAfterLeaveError`.
    * Если была попытка присоединиться в игру когда игра уже идет, вернет ошибку `connectAfterStartError`

## Ожидание начала игры

* **Тип**: `waitGameStart`
* **Параметры**:
* **Возврат**:
    * Если пользователь вне игры, то вернет ошибку `notInGameError`.
    * Если пользователь являетя хостом своей игры `UserHostError`.
    * Иначе будем ждать пока хост начнет игру и вернет ответ типа `GameWaitedSuccessfully` когда это случится


## Запуск игры

* **Тип**: `startGame`
* **Параметры**:
* **Возврат**:
    * Если пользователь вне игры, то вернет ошибку `notInGameError`.
    * Если пользователь не являетя хостом своей игры(такое кажется произойти не должно вообще) `notHostError`.
    * Иначе вернет ответ типа `GameStartedSuccessfully` и разморозится condvar.

## Выход из игры

* **Тип**: `leaveGame`
* **Параметры**:
* **Возврат**:
    * Если была попытка выйти вне игры, то вернет ошибку `notInGameError`.
    * Иначе вернет ответ типа `GameLeaveSuccessfully`.

## Добавить новый символ

* **Тип**: `addNewChar`
* **Параметры**:
    * `char` -- обязателен, строка из 1 символа; символ, который нажал пользователь.
* **Возврат**:
    * Если запрос был корректен, вернет ответ типа `checkResult` со следующими параметрами:
        * `isFullCorrect` -- булево, является ли буфер после добавления нового символа корректным. Если значение `true`,
          то необходимо перейти к новому слову.
        * `isPrefixCorrect` -- булево, является ли текущий буфер корректным префиксом.
        * `isEnd` -- булево, произошел ли конец игры.
    * Если запрос был вне игры, вернет ошибку `notInGameError`
    * Если формат был некорректным, вернет ошибку `wrongFormatError`.

## Удалить последний символ (backspace)

* **Тип**: `backspace`:
* **Параметры**:
* **Возврат**:
    * Если запрос был вне игры, вернет `notInGameError`,
    * Если буфер был пустым, вернет `emptyBufferError`,
    * Иначе, вернет `checkResult` с форматом, описанным выше.

## Получить новую строку

* **Тип**: `getNewLine`
* **Параметры**:
* **Возврат**:
    * Если запрос был вне игры, вернет `notInGameError`.
    * Иначе вернет `newLineResult`.
    * И упадет, если там был конец игры.

## Получить состояние всех игроков

* **Тип**: `getStates`
* **Параметры**:
* **Возврат**:
    * Если запрос был вне игры, вернет `notInGameError`,
    * Иначе вернет ответ `currentState`, содержащий поле `userStates`, которое содержит массив объектив со следующими
      полями:
        * `id` -- число, id пользователя
        * `wordsTyped` -- число, количество слов, которое напечатал пользователь в его последней строке.
        * `linesTyped` -- число, количество полных строк, которое напечатал пользователь.

# Тестовый эхо-запрос:

* **Тип**: `echo`
* **Параметры**:
    * Все, что угодно
* **Возврат**: просто возвращает `body`. 
